# Encrypt Now Backend

Этот проект реализует бэкенд для безопасного мессенджера со сквозным шифрованием. Он построен с использованием FastAPI и использует PostgreSQL для хранения данных.

## Основная функциональность

- **Сквозное шифрование:** Фронтенд обрабатывает все операции шифрования и дешифрования. Пользователи генерируют сид-фразу, из которой затем получаются приватный и публичный ключи.
- **Структура зашифрованного сообщения:** Внутри зашифрованного пакета содержится отметка времени отправления. Она используется клиентом-получателем после расшифровки для дополнительной защиты от replay-атак.
- **Защита от Replay-атак на сервере:** Так как сервер не имеет доступа к содержимому пакетов, он реализует защиту иначе. Бэкенд хранит хеши последних 50 полученных сообщений для каждого получателя. Если приходит пакет, хеш которого совпадает с одним из сохраненных, он отклоняется как дубликат.
- **Безопасная передача данных:** Фронтенд отправляет POST-запросы, содержащие зашифрованные данные сообщений.
- **Идентификация получателя:** Публичный ключ получателя включается в заголовок запроса, выступая в качестве его уникального идентификатора.
- **Идентификация отправителя:** Публичный ключ отправителя включается в заголовок запроса, выступая в качестве его уникального идентификатора.
- **Хранение сообщений:** Бэкенд получает зашифрованные пакеты и сохраняет их в базе данных PostgreSQL, связывая сообщение с отправителем и получателем через их уникальные идентификаторы.
- **Доставка через вебхук:** Если клиент, связанный с указанным публичным ключом, ожидает вебхук, бэкенд перенаправит ему сохраненный зашифрованный пакет.

Этот бэкенд выступает в роли безопасного посредника, облегчая зашифрованную связь без доступа к незашифрованному содержимому сообщений.

## Запуск и настройка

### С использованием Docker (Рекомендуемый способ)

1.  **Установите Docker и Docker Compose.**
    *   Инструкции по установке вы найдете на официальных сайтах [Docker](https://docs.docker.com/get-docker/) и [Docker Compose](https://docs.docker.com/compose/install/).

2.  **Создайте файл `.env`**
    *   Скопируйте файл `.env.example` и переименуйте его в `.env`.
    ```bash
    cp .env.example .env
    ```
    *   При необходимости измените значения переменных окружения в файле `.env`.

3.  **Запустите приложение**
    *   Выполните следующую команду в корневой директории проекта:
    ```bash
    docker-compose up -d --build
    ```
    *   Приложение будет доступно по адресу `http://localhost:8000`.

## API Reference

### POST /messages/

Сохраняет зашифрованное сообщение в базе данных.

- **Headers:**
  - `X-Sender-Public-Key` (обязательный): Публичный ключ отправителя.
  - `X-Recipient-Public-Key` (обязательный): Публичный ключ получателя.
- **Request Body:**
  - `binary`: Зашифрованное содержимое сообщения (ciphertext).
- **Success Response (200 OK):**
  ```json
  {
    "message_id": 123
  }
  ```
- **Error Responses:**
  - `400 Bad Request`: Тело запроса не может быть пустым.
  - `409 Conflict`: Обнаружено дублирующееся сообщение (защита от replay-атак).
  - `500 Internal Server Error`: Не удалось сохранить сообщение.

### GET /messages/

Извлекает исторические сообщения для указанного публичного ключа (отправленные и полученные).

- **Query Parameters:**
  - `public_key` (обязательный): Публичный ключ пользователя.
  - `since_id` (опциональный): Получить сообщения с ID, большим чем указанный.
  - `until_id` (опциональный): Получить сообщения с ID, меньшим чем указанный. Не может использоваться вместе с `since_id`.
  - `limit` (опциональный): Максимальное количество сообщений для извлечения (по умолчанию 100).
- **Success Response (200 OK):**
  - Массив объектов сообщений.
  ```json
  [
    {
      "id": 1,
      "sender_id": 1,
      "recipient_id": 2,
      "ciphertext": "...",
      "created_at": "2023-10-27T10:00:00Z"
    }
  ]
  ```
- **Error Responses:**
  - `400 Bad Request`: `since_id` и `until_id` не могут использоваться одновременно.

### GET /poll/messages

Реализует механизм long-polling для ожидания новых сообщений. Ответ приходит немедленно, если есть ожидающие сообщения, в противном случае соединение удерживается до `45` секунд.

- **Query Parameters:**
  - `public_key` (обязательный): Публичный ключ пользователя для проверки сообщений.
- **Success Response (200 OK):**
  - Массив объектов новых сообщений. Пустой массив, если новые сообщения не поступили в течение таймаута.
  ```json
  [
    {
      "id": 2,
      "sender_id": 2,
      "recipient_id": 1,
      "ciphertext": "...",
      "created_at": "2023-10-27T10:05:00Z"
    }
  ]
  ```
- **Error Responses:**
  - `404 Not Found`: Пользователь с указанным `public_key` не найден.
